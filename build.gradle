plugins {
    id 'java'
    id 'application'
    id('com.diffplug.spotless') version '8.1.0'
    id('com.palantir.java-format-spotless') version '2.83.0'
    id('com.palantir.java-format') version '2.83.0'
}

group = 'epox'
version = '2.4.1'
description = 'WebAOM - Web Anime-O-Matic (AniDB file identification and organization)'

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(21)
	}
}

// Get the Java toolchain's installation directory for use in Exec tasks
def javaToolchainService = project.extensions.getByType(JavaToolchainService)
def javaLauncher = javaToolchainService.launcherFor {
	languageVersion = JavaLanguageVersion.of(21)
}
def toolchainJavaHome = javaLauncher.map { it.metadata.installationPath.asFile }

application {
	mainClass = 'epox.webaom.WebAOM'
}

repositories {
	mavenCentral()
}

// Dependency configurations for different JAR variants
configurations {
	sqliteOnly
	allDrivers
}

dependencies {
	// SQLite is always included (embedded database)
	runtimeOnly 'org.xerial:sqlite-jdbc:3.51.0.0'
	sqliteOnly 'org.xerial:sqlite-jdbc:3.51.0.0'

	// External database drivers (PostgreSQL, MySQL)
	runtimeOnly 'org.postgresql:postgresql:42.7.8'
	runtimeOnly 'com.mysql:mysql-connector-j:9.5.0'

	allDrivers 'org.xerial:sqlite-jdbc:3.51.0.0'
	allDrivers 'org.postgresql:postgresql:42.7.8'
	allDrivers 'com.mysql:mysql-connector-j:9.5.0'
}

tasks.register('generateVersionProperties') {
	// Capture values during configuration time to avoid deprecated API usage
	def versionString = project.version.toString()
	def buildDate = new Date().format('yyyy-MM-dd')

	doLast {
		def propsFile = file("${layout.buildDirectory.get()}/resources/main/version.properties")
		propsFile.parentFile.mkdirs()
		def props = new Properties()
		props['version'] = versionString
		props['buildDate'] = buildDate
		propsFile.withWriter { props.store(it, null) }
	}
}

processResources.dependsOn generateVersionProperties

jar {
	manifest {
		attributes(
				'Main-Class': 'epox.webaom.WebAOM',
				'Implementation-Title': 'WebAOM',
				'Implementation-Version': version,
				'Created-By': 'epoximator',
				'Specification-Title': 'WebAOM',
				'Specification-Version': version,
				'Specification-Vendor': 'epoximator'
				)
	}

	from {
		configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
	}

	duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

// Lite JAR with SQLite only (smaller, for most users)
tasks.register('jarLite', Jar) {
	dependsOn classes, generateVersionProperties
	group = 'build'
	description = 'Creates a lite JAR with SQLite database only'

	archiveClassifier = 'lite'

	manifest {
		attributes(
				'Main-Class': 'epox.webaom.WebAOM',
				'Implementation-Title': 'WebAOM',
				'Implementation-Version': version,
				'Created-By': 'epoximator',
				'Specification-Title': 'WebAOM',
				'Specification-Version': version,
				'Specification-Vendor': 'epoximator'
				)
	}

	from sourceSets.main.output
	from("${layout.buildDirectory.get()}/resources/main")

	from {
		configurations.sqliteOnly.collect { it.isDirectory() ? it : zipTree(it) }
	}

	duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

// Full JAR with all database drivers
tasks.register('jarFull', Jar) {
	dependsOn classes, generateVersionProperties
	group = 'build'
	description = 'Creates a full JAR with all database drivers (SQLite, PostgreSQL, MySQL)'

	archiveClassifier = 'full'

	manifest {
		attributes(
				'Main-Class': 'epox.webaom.WebAOM',
				'Implementation-Title': 'WebAOM',
				'Implementation-Version': version,
				'Created-By': 'epoximator',
				'Specification-Title': 'WebAOM',
				'Specification-Version': version,
				'Specification-Vendor': 'epoximator'
				)
	}

	from sourceSets.main.output
	from("${layout.buildDirectory.get()}/resources/main")

	from {
		configurations.allDrivers.collect { it.isDirectory() ? it : zipTree(it) }
	}

	duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

tasks.named('build') {
	dependsOn jarLite, jarFull
}

tasks.withType(JavaCompile).configureEach {
	options.encoding = 'UTF-8'
	options.compilerArgs.addAll([
		'-Xlint:unchecked',
		'-Xlint:deprecation'
	])
}

spotless {
	java {
	}
}

// Native app packaging with jpackage (requires Java 21+)
def jpackageOutputDir = layout.buildDirectory.dir('installer')
def jlinkOutputDir = layout.buildDirectory.dir('jlink')
def appName = 'WebAOM'
def appDescription = 'AniDB file identification and organization tool'
def appVendor = 'epoximator'
def appCopyright = 'Copyright 2005-2010 epoximator'

// Modules required by the application (Swing + networking + database drivers)
def requiredModules = [
	'java.base',
	'java.desktop',
	'java.logging',
	'java.naming',
	'java.net.http',
	'java.prefs',
	'java.security.jgss',
	'java.sql',
	'java.xml',
	'jdk.crypto.ec',
	'jdk.unsupported'
].join(',')

tasks.register('jlink', Exec) {
	dependsOn build
	group = 'distribution'
	description = 'Creates a minimal custom JRE using jlink'

	def outputDir = jlinkOutputDir.get().asFile
	def jlinkExe = new File(toolchainJavaHome.get(), 'bin/jlink')

	commandLine jlinkExe.absolutePath,
			'--add-modules', requiredModules,
			'--strip-debug',
			'--no-man-pages',
			'--no-header-files',
			'--compress', 'zip-9',
			'--output', outputDir.absolutePath

	doFirst {
		delete outputDir
		println "Creating minimal JRE with jlink..."
	}

	doLast {
		println "Custom JRE created in: ${outputDir.absolutePath}"
	}
}

tasks.register('jpackage', Exec) {
	dependsOn jarLite, jlink
	group = 'distribution'
	description = 'Creates native application package for the current platform'

	def os = System.getProperty('os.name').toLowerCase()
	def packageType = os.contains('mac') ? 'dmg' :
			os.contains('win') ? 'msi' :
			os.contains('linux') ? 'deb' : 'app-image'

	def outputDir = jpackageOutputDir.get().asFile
	def jpackageExe = new File(toolchainJavaHome.get(), 'bin/jpackage')

	def args = [
		jpackageExe.absolutePath,
		'--input',
		"${layout.buildDirectory.get()}/libs",
		'--main-jar',
		"webaom-${version}-lite.jar",
		'--name',
		appName,
		'--app-version',
		version,
		'--description',
		appDescription,
		'--vendor',
		appVendor,
		'--copyright',
		appCopyright,
		'--type',
		packageType,
		'--runtime-image',
		jlinkOutputDir.get().asFile.absolutePath,
		'--dest',
		outputDir.absolutePath
	]

	// Platform-specific options
	if (os.contains('mac')) {
		args.addAll([
			'--mac-package-name',
			appName,
			'--mac-package-identifier',
			'epox.webaom'
		])
		def macIcon = file('src/main/resources/webaom.icns')
		if (macIcon.exists()) {
			args.addAll([
				'--icon',
				macIcon.absolutePath
			])
		}
	} else if (os.contains('win')) {
		args.addAll([
			'--win-menu',
			'--win-shortcut',
			'--win-dir-chooser'
		])
		def winIcon = file('src/main/resources/webaom.ico')
		if (winIcon.exists()) {
			args.addAll([
				'--icon',
				winIcon.absolutePath
			])
		}
	} else if (os.contains('linux')) {
		args.addAll([
			'--linux-shortcut',
			'--linux-menu-group',
			'Utility'
		])
		def linuxIcon = file('src/main/resources/webaom.png')
		if (linuxIcon.exists()) {
			args.addAll([
				'--icon',
				linuxIcon.absolutePath
			])
		}
	}

	commandLine args

	doFirst {
		// Unmount any existing WebAOM volumes to prevent hdiutil conflicts
		if (System.getProperty('os.name').toLowerCase().contains('mac')) {
			try {
				[
					'hdiutil',
					'detach',
					'/Volumes/WebAOM',
					'-force',
					'-quiet'
				].execute().waitFor()
			} catch (Exception ignored) {}
		}
		outputDir.mkdirs()
		println "Creating ${packageType} package with minimal runtime..."
	}

	doLast {
		println "Package created in: ${outputDir.absolutePath}"
	}
}

tasks.register('jpackageAppImage', Exec) {
	dependsOn jarLite, jlink
	group = 'distribution'
	description = 'Creates a portable app-image (no installer) for the current platform'

	def outputDir = jpackageOutputDir.get().asFile
	def jpackageExe = new File(toolchainJavaHome.get(), 'bin/jpackage')

	def args = [
		jpackageExe.absolutePath,
		'--input',
		"${layout.buildDirectory.get()}/libs",
		'--main-jar',
		"webaom-${version}-lite.jar",
		'--name',
		appName,
		'--app-version',
		version,
		'--description',
		appDescription,
		'--vendor',
		appVendor,
		'--copyright',
		appCopyright,
		'--type',
		'app-image',
		'--runtime-image',
		jlinkOutputDir.get().asFile.absolutePath,
		'--dest',
		outputDir.absolutePath
	]

	def os = System.getProperty('os.name').toLowerCase()
	if (os.contains('mac')) {
		def macIcon = file('src/main/resources/webaom.icns')
		if (macIcon.exists()) {
			args.addAll([
				'--icon',
				macIcon.absolutePath
			])
		}
	} else if (os.contains('win')) {
		def winIcon = file('src/main/resources/webaom.ico')
		if (winIcon.exists()) {
			args.addAll([
				'--icon',
				winIcon.absolutePath
			])
		}
	} else if (os.contains('linux')) {
		def linuxIcon = file('src/main/resources/webaom.png')
		if (linuxIcon.exists()) {
			args.addAll([
				'--icon',
				linuxIcon.absolutePath
			])
		}
	}

	commandLine args

	doFirst {
		outputDir.mkdirs()
		println "Creating app-image with minimal runtime..."
	}

	doLast {
		println "App image created in: ${outputDir.absolutePath}"
	}
}

// AppImage packaging for Linux (universal Linux format)
tasks.register('appimage') {
	dependsOn jpackageAppImage
	group = 'distribution'
	description = 'Creates an AppImage for Linux distribution'
	onlyIf { System.getProperty('os.name').toLowerCase().contains('linux') }

	def outputDir = jpackageOutputDir.get().asFile
	def appDir = new File(outputDir, "${appName}.AppDir")
	def appImageName = "${appName}-${version}-x86_64.AppImage"

	doFirst {
		println "Creating AppImage..."

		// Clean previous AppDir
		if (appDir.exists()) {
			delete(appDir)
		}
		appDir.mkdirs()

		// Copy jpackage app-image to AppDir
		def jpackageApp = new File(outputDir, appName)
		if (!jpackageApp.exists()) {
			throw new GradleException("jpackage app-image not found at ${jpackageApp}")
		}
		copy {
			from jpackageApp
			into appDir
		}

		// Copy AppRun launcher
		copy {
			from 'src/main/resources/AppRun'
			into appDir
		}
		file("${appDir}/AppRun").setExecutable(true)

		// Copy .desktop file
		copy {
			from 'src/main/resources/WebAOM.desktop'
			into appDir
			filter { line ->
				if (line == 'Terminal=false') {
					return "Terminal=false\nX-AppImage-Version=${version}"
				}
				line
			}
		}

		// Copy icon and create .DirIcon symlink
		copy {
			from 'src/main/resources/webaom.png'
			into appDir
		}
		// Create .DirIcon symlink (required by AppImage)
		ant.symlink(link: "${appDir}/.DirIcon", resource: 'webaom.png', overwrite: true)
	}

		doLast {
		// Run appimagetool with update information for Gear Lever
		// The update URL format is: gh-releases-zsync|owner|repo|tag|filename.zsync
		// Using 'latest' for tag to always fetch the newest release
		def updateInfo = "gh-releases-zsync|alysson-souza|webaom|latest|WebAOM-*-x86_64.AppImage.zsync"
		def result = exec {
			workingDir outputDir
			environment 'ARCH', 'x86_64'
			commandLine 'appimagetool', '-u', updateInfo, appDir.name, appImageName
			ignoreExitValue = true
		}
		if (result.exitValue != 0) {
			throw new GradleException("appimagetool failed with exit code ${result.exitValue}")
		}

		// Clean up AppDir
		delete(appDir)

		println "AppImage created: ${new File(outputDir, appImageName).absolutePath}"
	}
}
